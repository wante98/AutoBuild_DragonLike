import { v4 as uuid } from 'uuid';
import { config } from '../config.js';
import { BedrockRuntimeClient, InvokeModelCommand } from '@aws-sdk/client-bedrock-runtime';

// Use Bedrock Runtime (Claude via Bedrock) with AWS credentials from env.
const bedrockClient = new BedrockRuntimeClient({ region: config.awsRegion });

async function invokeClaude(messages, system, max_tokens = 1200, temperature = 0.2) {
  const body = {
    anthropic_version: 'bedrock-2023-05-31',
    max_tokens,
    temperature,
    system,
    messages,
  };
  const command = new InvokeModelCommand({
    modelId: config.bedrockModelId,
    contentType: 'application/json',
    accept: 'application/json',
    body: JSON.stringify(body),
  });
  const response = await bedrockClient.send(command);
  const raw = new TextDecoder('utf-8').decode(response.body);
  const parsed = JSON.parse(raw);
  let text = '';
  if (parsed?.content && Array.isArray(parsed.content)) {
    const textBlock = parsed.content.find((c) => c.type === 'text');
    text = textBlock?.text || '';
  }
  if (!text && parsed?.output_text) text = parsed.output_text;
  if (!text && parsed?.completion) text = parsed.completion;
  if (!text) text = typeof parsed === 'string' ? parsed : JSON.stringify(parsed);
  return text;
}

// Stub: call AWS Bedrock to parse NL prompt to structured workflow
export async function parsePromptToWorkflow(prompt) {
  try {
    const system = [
      'You convert a natural language workflow description into a strict JSON object with keys: id, name, sourcePrompt, steps[], integrations[], metadata{model}.',
      'Each step has: id, type (condition|action), and either expression or action+params.',
      'Return ONLY the JSON object with no extra text or markdown.',
    ].join(' ');
    const messages = [
      { role: 'user', content: [{ type: 'text', text: `PROMPT:\n${prompt}` }] },
    ];
    const completion = await invokeClaude(messages, 800, 0.2);
    let text = (completion || '').trim();
    const fence = text.match(/```json\n([\s\S]*?)```/i);
    if (fence) text = fence[1];
    const workflow = JSON.parse(text);
    if (!workflow.metadata) workflow.metadata = {};
    workflow.metadata.model = config.bedrockModelId;
    if (!workflow.id) workflow.id = uuid();
    if (!workflow.sourcePrompt) workflow.sourcePrompt = prompt;
    return workflow;
  } catch (err) {
    console.warn('[Bedrock Runtime] parse fallback:', err?.message || err);
  }

  // Fallback stub
  return {
    id: uuid(),
    name: 'Generated Workflow',
    sourcePrompt: prompt,
    steps: [
      { id: 's1', type: 'condition', expression: "ticket.priority == 'high'" },
      { id: 's2', type: 'action', action: 'notify_manager', params: { channel: 'email' } },
    ],
    integrations: ['superops'],
    metadata: { model: config.bedrockModelId },
  };
}

// Stub: call Bedrock code generation to output Python/Lambda code
export async function generateCodeForWorkflow(workflow) {
  try {
    const system = [
      'Generate a single, self-contained SuperOps code using Python 3.11 file from the workflow JSON the user provides.',
      'Return ONLY the Python code. Do not include explanations or Markdown fences.',
      'The handler function must be named `handler(event, context)`.',
      'Assume no external dependencies beyond Python stdlib.',
    ].join(' ');
    const messages = [
      { role: 'user', content: [{ type: 'text', text: `WORKFLOW JSON:\n${JSON.stringify(workflow, null, 2)}` }] },
    ];
    const completion = await invokeClaude(messages, system, 1800, 0.2);
    const codeText = (completion || '').trim();
    if (codeText) {
      console.log('Successfully calling Bedrock')
      // Return model reply directly as code (no fence stripping) per user's preference
      return { language: 'python', runtime: 'python3.11', code: codeText };
    }
  } catch (err) {
    console.warn('[Bedrock Runtime] generate fallback:', err?.message || err);
  }
  const code0 ='222';
  const code = `# Auto-generated by Bedrock model: ${config.bedrockModelId}\n# Workflow: ${workflow.name}\nimport json\n\n# Mock SuperOps client\nclass SuperOps:\n    def notify_manager(self, ticket_id, channel='email'):\n        return { 'status': 'sent', 'ticket_id': ticket_id, 'channel': channel }\n\n# Handler for AWS Lambda\ndef handler(event, context):\n    ticket = event.get('ticket', {})\n    if ticket.get('priority') == 'high':\n        client = SuperOps()\n        result = client.notify_manager(ticket.get('id'), channel='email')\n        return { 'action': 'notify_manager', 'result': result }\n    return { 'action': 'none' }\n`;
  return { language: 'python', runtime: 'python3.11', code0 };
}